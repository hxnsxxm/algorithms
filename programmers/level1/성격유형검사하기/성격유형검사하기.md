### 문제 링크

[프로그래머스/성격 유형 검사하기](https://school.programmers.co.kr/learn/courses/30/lessons/118666)

<br>

### 문제

나만의 카카오 성격 유형 검사지를 만들려고 합니다.  
성격 유형 검사는 다음과 같은 4개 지표로 성격 유형을 구분합니다. 성격은 각 지표에서 두 유형 중 하나로 결정됩니다.

|지표 번호|성격 유형|
|---|---|
|1번 지표|라이언형(R), 튜브형(T)|
|2번 지표|콘형(C), 프로도형(F)|
|3번 지표|제이지형(J), 무지형(M)|
|4번 지표|어피치형(A), 네오형(N)|

4개의 지표가 있으므로 성격 유형은 총 16(=2 x 2 x 2 x 2)가지가 나올 수 있습니다. 예를 들어, "RFMN"이나 "TCMA"와 같은 성격 유형이 있습니다.

검사지에는 총 `n`개의 질문이 있고, 각 질문에는 아래와 같은 7개의 선택지가 있습니다.

- `매우 비동의`
- `비동의`
- `약간 비동의`
- `모르겠음`
- `약간 동의`
- `동의`
- `매우 동의`

각 질문은 1가지 지표로 성격 유형 점수를 판단합니다.

예를 들어, 어떤 한 질문에서 4번 지표로 아래 표처럼 점수를 매길 수 있습니다.

|선택지|성격 유형 점수|
|---|---|
|`매우 비동의`|네오형 3점|
|`비동의`|네오형 2점|
|`약간 비동의`|네오형 1점|
|`모르겠음`|어떤 성격 유형도 점수를 얻지 않습니다|
|`약간 동의`|어피치형 1점|
|`동의`|어피치형 2점|
|`매우 동의`|어피치형 3점|

이때 검사자가 질문에서 `약간 동의` 선택지를 선택할 경우 어피치형(A) 성격 유형 1점을 받게 됩니다. 만약 검사자가 `매우 비동의` 선택지를 선택할 경우 네오형(N) 성격 유형 3점을 받게 됩니다.

**위 예시처럼 네오형이 비동의, 어피치형이 동의인 경우만 주어지지 않고, 질문에 따라 네오형이 동의, 어피치형이 비동의인 경우도 주어질 수 있습니다.**  
하지만 각 선택지는 고정적인 크기의 점수를 가지고 있습니다.

- `매우 동의`나 `매우 비동의` 선택지를 선택하면 3점을 얻습니다.
- `동의`나 `비동의` 선택지를 선택하면 2점을 얻습니다.
- `약간 동의`나 `약간 비동의` 선택지를 선택하면 1점을 얻습니다.
- `모르겠음` 선택지를 선택하면 점수를 얻지 않습니다.

검사 결과는 모든 질문의 성격 유형 점수를 더하여 각 지표에서 더 높은 점수를 받은 성격 유형이 검사자의 성격 유형이라고 판단합니다. 단, 하나의 지표에서 각 성격 유형 점수가 같으면, 두 성격 유형 중 사전 순으로 빠른 성격 유형을 검사자의 성격 유형이라고 판단합니다.

질문마다 판단하는 지표를 담은 1차원 문자열 배열 `survey`와 검사자가 각 질문마다 선택한 선택지를 담은 1차원 정수 배열 `choices`가 매개변수로 주어집니다. 이때, 검사자의 성격 유형 검사 결과를 지표 번호 순서대로 return 하도록 solution 함수를 완성해주세요.

<br>

### 입력 & 출력

##### 제한사항

- 1 ≤ `survey`의 길이 ( = `n`) ≤ 1,000
    - `survey`의 원소는 `"RT", "TR", "FC", "CF", "MJ", "JM", "AN", "NA"` 중 하나입니다.
    - `survey[i]`의 첫 번째 캐릭터는 i+1번 질문의 비동의 관련 선택지를 선택하면 받는 성격 유형을 의미합니다.
    - `survey[i]`의 두 번째 캐릭터는 i+1번 질문의 동의 관련 선택지를 선택하면 받는 성격 유형을 의미합니다.
- `choices`의 길이 = `survey`의 길이

    - `choices[i]`는 검사자가 선택한 i+1번째 질문의 선택지를 의미합니다.
    - 1 ≤ `choices`의 원소 ≤ 7

  |`choices`|뜻|
      |---|---|
  |1|매우 비동의|
  |2|비동의|
  |3|약간 비동의|
  |4|모르겠음|
  |5|약간 동의|
  |6|동의|
  |7|매우 동의|

<br>

##### 입출력 예

| survey                           | choices         | result   |
| -------------------------------- | --------------- | -------- |
| `["AN", "CF", "MJ", "RT", "NA"]` | [5, 3, 2, 7, 5] | `"TCMA"` |
| `["TR", "RT", "TR"]`             | [7, 1, 3]       | `"RCJA"` |

<br>

## 풀이

성격은 각 지표에서 두 유형 중 하나로 결정된다.  

이것은 2차원 배열로 한 번에 관리할 수 있다. 이때 <b>사전 순</b>으로 정렬해놓는 것을 유의한다. 
```
0 | R, T
1 | C, F
2 | J, M
3 | A, N
```

또한 성격 유형 선택지는 `1` ~ `7`의 고유 번호를 가지기 때문에 1차원 배열로 선택지별 점수를 관리할 수 있다. 
```
0 | -1 (의미 없음)
1 | 3
2 | 2
3 | 1
4 | 0
5 | 1
6 | 2
7 | 3
```
  
이제는 입력(`survey`, `choices`) 각 유형별 점수 합계를 `HashMap`으로 관리하고, 지표별로 점수가 높은 유형을 
선택하여 반환한다.  

<br>

### 구현 코드
```java
package 성격유형검사하기;

import java.util.HashMap;
import java.util.Map;

public class 성격유형검사하기 {

    private static int[] score = {0, 3, 2, 1, 0, 1, 2, 3};
    private static String[][] type = {
            {"R", "T"}, {"C", "F"}, {"J", "M"}, {"A", "N"}
    };

    public String solution(String[] survey, int[] choices) {
        String answer = "";

        Map<String, Integer> map = new HashMap<>();
        for (String[] t : type) {
            map.put(t[0], 0);
            map.put(t[1], 0);
        }

        for (int i = 0; i < survey.length; i++) {
            String first = survey[i].charAt(0) + "";
            String second = survey[i].charAt(1) + "";

            if (choices[i] < 4) {
                map.put(first, map.get(first) + score[choices[i]]);
            } else if (choices[i] > 4) {
                map.put(second, map.get(second) + score[choices[i]]);
            }
        }

        for (String[] t : type) {
            if (map.get(t[0]) >= map.get(t[1]))
                answer += t[0];
            else
                answer += t[1];
        }

        return answer;
    }
}
```